@tool
@icon("res://addons/blender_to_godot_pipeline/icon.svg")
## Blender-to-Godot entity importer. Reads from an entity definition JSON and
## assigns The types/values of nodes in the Godot scene corresponding to the
## objects in Blender scene.
class_name BTGImporter extends Node3D

const AUTO_IMPORT_DELAY: int = 1

@export_group("Run BTG Import")
## Run BTG import (This is a button)
@export var import: bool = false:
	set(value):
		import = false
		if entity_definition_path.is_empty():
			push_warning("Please populate `entity_definition_path` field!")
			return
		_import()
@export_group("BTG Import Settings")
## Path to entity definition JSON generated by the Blender addon
@export var entity_definition_path: String = "":
	set(value):
		entity_definition_path = value
		file_update_time = FileAccess.get_modified_time(value)
## Whether or not import should run automatically when the above JSON is updated
@export var auto_import: bool = false:
	set(value):
		auto_import = value
		if value:
			if entity_definition_path.is_empty():
				push_warning("Please populate `entity_definition_path` field!")
			timer.start()
		else:
			timer.stop()

## TODO
@export var class_map: Dictionary

## Handle assignment of custom types defind in your entity template JSON.
## Formatted as `Dictionary(String: Callable)` [br]
## * `String`: "type" from the entity template/definition JSON [br]
## * `Callable`: takes in "value" from entity definition as its only param
## and returns the final, modified value [br]
## NOTE: Needs to be updated manually because Godot does not support `Callable`
var custom_hanlders = {"custom_float": BTGExampleClass1.custom_float_handler}
var file_update_time: int = -1
var timer: Timer


func _init():
	if not Engine.is_editor_hint():
		return

	timer = Timer.new()
	timer.timeout.connect(_auto_import)
	timer.one_shot = false
	timer.wait_time = AUTO_IMPORT_DELAY
	add_child(timer)


func _ready():
	auto_import = auto_import


func _auto_import():
	if not FileAccess.file_exists(entity_definition_path):
		return

	var file_update_time = FileAccess.get_modified_time(entity_definition_path)
	if self.file_update_time < file_update_time:
		self.file_update_time = file_update_time
		_import()


## Run import when button is pressed
func _import() -> void:
	var godot_import_file = FileAccess.open(entity_definition_path, FileAccess.READ)
	if godot_import_file == null:
		push_error(error_string(FileAccess.get_open_error()))
		return

	var import_text = godot_import_file.get_as_text()

	var json = JSON.new()
	json.parse(import_text)
	var entity_def = json.data

	var num_errors = _import_entities_from_def(entity_def, self)
	if num_errors == 0:
		print("Finished import with no errors!")
	else:
		print("Finished import with %d errors (see warnings)" % num_errors)


## Recursively search through nodes and replace based on import JSON
func _import_entities_from_def(entity_def: Dictionary, node: Node3D) -> int:
	var num_errors = 0
	var node_name = node.name

	# Verify that the class_name is valid
	var new_node = null
	if node_name in entity_def:
		var node_class_name = entity_def[node_name]["class"]

		# Populate new node
		if node_class_name in class_map:
			new_node = load(class_map[node_class_name]).new()
		else:
			new_node = ClassDB.instantiate(node_class_name)
			if new_node == null:
				push_warning("Class not defined: Failed on (Node: %s, class_name: %s)" % [node_name, node_class_name])
				num_errors += 1

	# If the class_name is valid, continue copying from definition
	if new_node != null:
		new_node.transform = node.transform
		new_node.name = node.name

		# Replace and free
		node.replace_by(new_node, true)
		node.free()
		node = new_node

		# Assign values
		var variables = entity_def[node_name]["variables"]
		for variable in variables:
			if not variable in node:
				push_warning("Missing variable definition! Failed on (Node: %s, variable: %s)" % [node_name, variable])
				num_errors += 1
				continue

			var type = variables[variable]["type"]
			var value = variables[variable]["value"]

			if type in ["int", "String", "bool", "float", "enum"]:
				node.set(variable, value)
			else:
				var converted_value = _cast_to_type(value, type)
				if converted_value == null:
					push_warning(
						(
							"Failed to cast variable type! Failed on (Node: %s, type: %s, variable: %s)"
							% [node_name, type, variable]
						)
					)
					num_errors += 1
					continue
				node.set(variable, converted_value)

	# Recursively search children
	if node.get_children().is_empty():
		return num_errors
	for child in node.get_children():
		# Need to add timer to scene for auto-import to function, ignore it when navigating scene tree
		if child == timer:
			continue
		num_errors += _import_entities_from_def(entity_def, child)

	return num_errors


## Convert `value` to type `type`
func _cast_to_type(value, type: String):
	if type == "list":
		return str_to_var(value)
	if type == "Vector3":
		value = value.replace("(", "[")
		value = value.replace(")", "]")
		value = str_to_var(value)
		return Vector3(value[0], value[1], value[2])
	if type == "Vector3i":
		value = value.replace("(", "[")
		value = value.replace(")", "]")
		value = str_to_var(value)
		return Vector3i(value)
	if type in custom_hanlders:
		value = custom_hanlders[type].call(value)
		return value

	return null
