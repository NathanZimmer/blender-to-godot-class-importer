@tool
@icon("res://addons/blender_to_godot_pipeline/icon.svg")
## Blender-to-Godot entity importer. Reads from an entity definition JSON and
## assigns The types/values of nodes in the Godot scene corresponding to the
## objects in Blender scene.
class_name BTGImporter extends Node3D

@export_group("Run BTG Import")
## Run BTG import (This is a button)
@export var import: bool = false:
	set(value):
		_on_import_button_pressed()
		import = false

@export_group("BTG Import Settings")
## Path to entity definition JSON generated by the Blender addon
@export var entity_definition_path: String = ""
## Handle assignment of custom types defind in your entity template JSON.
## Formatted as `Dictionary(String: Callable)` [br]
## * `String`: "type" from the entity template/definition JSON [br]
## * `Callable`: takes in "value" from entity definition as its only param
## and returns the final, modified value
@export var custom_hanlders: Dictionary


## Run import when button is pressed
func _on_import_button_pressed() -> void:
	if entity_definition_path.is_empty():
		push_warning("Please populate `entity_definition_path` field!")
		return

	var godot_import_file = FileAccess.open(entity_definition_path, FileAccess.READ)
	if godot_import_file == null:
		push_error(error_string(FileAccess.get_open_error()))
		return

	var import_text = godot_import_file.get_as_text()

	var json = JSON.new()
	json.parse(import_text)
	var entity_def = json.data

	var num_errors = _import_entities_from_def(entity_def, self)
	if num_errors == 0:
		print('Finished import with no errors!')
	else:
		print('Finished import with %d errors (see warnings)' % num_errors)


## Recursively search through nodes and replace based on import JSON
func _import_entities_from_def(entity_def: Dictionary, node: Node3D) -> int:
	var num_errors = 0
	var node_name = node.name

	# Verify that the class_name is valid
	var new_node = null
	if node_name in entity_def:
		# Populate new node
		new_node = ClassDB.instantiate(entity_def[node_name]["class"])
		if new_node == null:
			push_warning("Class not defined: Failed on (Node: %s, class_name: %s)" % node_name, entity_def[node_name]["class"])
			num_errors += 1

	# If the class_name is valid, continue copying from definition
	if new_node != null:
		new_node.global_transform = node.global_transform
		new_node.name = node.name

		# Replace and free
		node.replace_by(new_node, true)
		node.free()
		node = new_node

		# Assign values
		var variables = entity_def[node_name]["variables"]
		for variable in variables:
			if not variable in node:
				push_warning("Missing variable definition! Failed on (Node: %s, variable: %s)" % node_name, variable)
				num_errors += 1
				continue

			var type = variables[variable]["type"]
			var value = variables[variable]["value"]

			if type in ["int", "String", "bool", "float"]:
				node.set(variable, value)
			else:
				var converted_value = _cast_to_type(value, type)
				if converted_value == null:
					push_warning("Failed to cast variable type! Failed on (Node: %s, type: %s, variable: %s)" % node_name, type, variable)
					num_errors += 1
					continue
				node.set(variable, converted_value)

	# Recursively search children
	if node.get_children().is_empty():
		return num_errors
	for child in node.get_children():
		num_errors += _import_entities_from_def(entity_def, child)

	return num_errors


## Convert `value` to type `type`
func _cast_to_type(value, type: String):
	if type == "list":
		return str_to_var(value)
	if type == "Vector3":
		value = value.replace("(", "[")
		value = value.replace(")", "]")
		value = str_to_var(value)
		return Vector3(value[0], value[1], value[2])
	if type == "Vector3i":
		value = value.replace("(", "[")
		value = value.replace(")", "]")
		value = str_to_var(value)
		return Vector3i(value)
	if type in custom_hanlders:
		value = custom_hanlders[type].call(value)
	if type in ["int", "String", "bool", "float"]:
		return value

	return null
